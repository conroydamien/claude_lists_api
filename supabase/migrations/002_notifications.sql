-- Notification system for watched cases
-- Creates tables for tracking watched cases and notification history
-- Uses Supabase Realtime for in-app notifications (no push needed)

-- Watched cases: tracks which cases each user is watching
CREATE TABLE watched_cases (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    list_source_url TEXT NOT NULL,
    case_number TEXT NOT NULL,
    source TEXT NOT NULL DEFAULT 'manual', -- 'manual' or 'auto' (from commenting)
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    UNIQUE(user_id, list_source_url, case_number)
);

-- Indexes for efficient lookups
CREATE INDEX watched_cases_user_idx ON watched_cases (user_id);
CREATE INDEX watched_cases_case_idx ON watched_cases (list_source_url, case_number);

-- Notifications: in-app notification history (delivered via Realtime)
CREATE TABLE notifications (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    type TEXT NOT NULL, -- 'comment', 'status_done', 'status_undone'
    list_source_url TEXT NOT NULL,
    case_number TEXT NOT NULL,
    case_title TEXT, -- Cached for display
    actor_name TEXT NOT NULL, -- Who triggered the notification
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    content TEXT, -- Comment content for comment notifications
    read BOOLEAN NOT NULL DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX notifications_user_idx ON notifications (user_id, read, created_at DESC);
CREATE INDEX notifications_unread_idx ON notifications (user_id) WHERE NOT read;

-- Enable RLS
ALTER TABLE watched_cases ENABLE ROW LEVEL SECURITY;
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;

-- Watched cases policies
CREATE POLICY "Users can view own watched cases"
    ON watched_cases FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own watched cases"
    ON watched_cases FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own watched cases"
    ON watched_cases FOR DELETE
    USING (auth.uid() = user_id);

-- Notifications policies
CREATE POLICY "Users can view own notifications"
    ON notifications FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can update own notifications"
    ON notifications FOR UPDATE
    USING (auth.uid() = user_id);

-- Enable realtime for notifications and watched_cases (this is how the app gets notified)
ALTER PUBLICATION supabase_realtime ADD TABLE notifications;
ALTER PUBLICATION supabase_realtime ADD TABLE watched_cases;

-- Function to auto-watch when user comments on a case
CREATE OR REPLACE FUNCTION auto_watch_on_comment()
RETURNS TRIGGER AS $$
BEGIN
    -- Insert watched case if not already watching
    INSERT INTO watched_cases (user_id, list_source_url, case_number, source)
    VALUES (NEW.user_id, NEW.list_source_url, NEW.case_number, 'auto')
    ON CONFLICT (user_id, list_source_url, case_number) DO NOTHING;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger for auto-watch on comment
CREATE TRIGGER on_comment_insert_auto_watch
    AFTER INSERT ON comments
    FOR EACH ROW
    EXECUTE FUNCTION auto_watch_on_comment();

-- Function to create notifications when comment is added
CREATE OR REPLACE FUNCTION notify_on_comment()
RETURNS TRIGGER AS $$
DECLARE
    watcher RECORD;
BEGIN
    -- Create notification for each watcher (except the commenter)
    FOR watcher IN
        SELECT DISTINCT user_id
        FROM watched_cases
        WHERE list_source_url = NEW.list_source_url
        AND case_number = NEW.case_number
        AND user_id != NEW.user_id
    LOOP
        INSERT INTO notifications (
            user_id, type, list_source_url, case_number,
            actor_name, actor_id, content
        ) VALUES (
            watcher.user_id, 'comment', NEW.list_source_url, NEW.case_number,
            NEW.author_name, NEW.user_id, NEW.content
        );
    END LOOP;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger for notifications on comment
CREATE TRIGGER on_comment_insert_notify
    AFTER INSERT ON comments
    FOR EACH ROW
    EXECUTE FUNCTION notify_on_comment();

-- Function to create notifications when case status changes
CREATE OR REPLACE FUNCTION notify_on_status_change()
RETURNS TRIGGER AS $$
DECLARE
    watcher RECORD;
    notification_type TEXT;
    actor_email TEXT;
BEGIN
    -- Only notify if done status actually changed
    IF OLD.done = NEW.done THEN
        RETURN NEW;
    END IF;

    -- Determine notification type
    notification_type := CASE WHEN NEW.done THEN 'status_done' ELSE 'status_undone' END;

    -- Get actor email
    SELECT email INTO actor_email FROM auth.users WHERE id = NEW.updated_by;

    -- Create notification for each watcher (except the actor)
    FOR watcher IN
        SELECT DISTINCT user_id
        FROM watched_cases
        WHERE list_source_url = NEW.list_source_url
        AND case_number = NEW.case_number
        AND user_id != NEW.updated_by
    LOOP
        INSERT INTO notifications (
            user_id, type, list_source_url, case_number,
            actor_name, actor_id
        ) VALUES (
            watcher.user_id, notification_type, NEW.list_source_url, NEW.case_number,
            COALESCE(actor_email, 'Someone'), NEW.updated_by
        );
    END LOOP;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger for notifications on status change
CREATE TRIGGER on_status_change_notify
    AFTER UPDATE ON case_status
    FOR EACH ROW
    EXECUTE FUNCTION notify_on_status_change();

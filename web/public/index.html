<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Claude Lists</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      max-width: 800px;
      margin: 40px auto;
      padding: 0 20px;
    }
    h1 {
      margin-bottom: 20px;
    }
    select, input[type="date"] {
      font-size: 1rem;
      padding: 6px 10px;
      margin-bottom: 20px;
    }
    .filters {
      display: flex;
      gap: 20px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }
    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .filter-group label {
      font-size: 0.85rem;
      color: #666;
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    th, td {
      text-align: left;
      padding: 8px 12px;
      border-bottom: 1px solid #ddd;
    }
    th {
      background: #f5f5f5;
    }
    .done td:not(:first-child) {
      text-decoration: line-through;
      color: #999;
    }
    tr:not(.done) {
      cursor: pointer;
    }
    tr:not(.done):hover {
      background: #f9f9f9;
    }
    .header-row {
      background: #f0f7ff;
      cursor: default;
    }
    .header-row:hover {
      background: #f0f7ff;
    }
    .header-cell {
      font-weight: 600;
      color: #1565c0;
      font-size: 0.95rem;
      padding: 12px;
      border-left: 3px solid #1976d2;
    }
    .undo-btn, .chat-btn {
      background: none;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 2px 6px;
      cursor: pointer;
      font-size: 1.1rem;
      line-height: 1;
      color: #666;
    }
    .undo-btn:hover, .chat-btn:hover {
      background: #eee;
    }
    .chat-btn {
      margin-left: 4px;
    }
    .chat-btn.has-comments {
      background: #e3f2fd;
      border-color: #90caf9;
    }
    .comment-count {
      font-size: 0.75rem;
      margin-left: 2px;
    }
    #message {
      color: #666;
      font-style: italic;
    }
    /* Chat panel styles */
    .chat-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    .chat-overlay[hidden] {
      display: none;
    }
    .chat-panel {
      background: white;
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    }
    .chat-header {
      padding: 12px 16px;
      border-bottom: 1px solid #ddd;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .chat-header h3 {
      margin: 0;
      font-size: 1rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .chat-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: #666;
      line-height: 1;
    }
    .chat-close:hover {
      color: #333;
    }
    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      min-height: 200px;
      max-height: 400px;
    }
    .chat-message {
      margin-bottom: 12px;
      padding: 8px 12px;
      background: #f5f5f5;
      border-radius: 8px;
    }
    .chat-message.own {
      background: #e3f2fd;
      border-left: 3px solid #2196f3;
    }
    .chat-message-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
      font-size: 0.85rem;
      color: #666;
    }
    .chat-message-author {
      font-weight: 600;
      color: #333;
    }
    .chat-message-delete {
      background: none;
      border: none;
      color: #ccc;
      cursor: pointer;
      font-size: 0.9rem;
      padding: 0 4px;
      margin-left: 8px;
    }
    .chat-message-delete:hover {
      color: #e53935;
    }
    .chat-message-content {
      white-space: pre-wrap;
      word-break: break-word;
    }
    .chat-empty {
      color: #999;
      text-align: center;
      padding: 40px 20px;
    }
    .chat-input-area {
      padding: 12px 16px;
      border-top: 1px solid #ddd;
    }
    .chat-author-input {
      width: 100%;
      padding: 8px;
      margin-bottom: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 0.9rem;
    }
    .chat-input-row {
      display: flex;
      gap: 8px;
    }
    .chat-content-input {
      flex: 1;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 0.9rem;
      resize: none;
    }
    .chat-send-btn {
      padding: 8px 16px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .chat-send-btn:hover {
      background: #0056b3;
    }
    .chat-send-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    /* Auth UI styles */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    .header h1 {
      margin: 0;
    }
    .user-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .user-name {
      font-weight: 500;
      color: #333;
    }
    .auth-btn {
      padding: 8px 16px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: white;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .auth-btn:hover {
      background: #f5f5f5;
    }
    .auth-btn.login {
      background: #007bff;
      color: white;
      border-color: #007bff;
    }
    .auth-btn.login:hover {
      background: #0056b3;
    }
    .login-prompt {
      text-align: center;
      padding: 60px 20px;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Claude Lists</h1>
    <div class="user-info" id="user-info">
      <span class="user-name" id="user-name"></span>
      <button class="auth-btn" id="auth-btn">Loading...</button>
    </div>
  </div>

  <div class="filters">
    <div class="filter-group">
      <label for="date-filter">Date:</label>
      <input type="date" id="date-filter">
    </div>
    <div class="filter-group">
      <label for="venue-filter">Venue:</label>
      <select id="venue-filter">
        <option value="">All venues</option>
      </select>
    </div>
  </div>

  <label for="list-select">Choose a list:</label>
  <select id="list-select">
    <option value="">-- Select a list --</option>
  </select>

  <table id="items-table" hidden>
    <thead>
      <tr>
        <th></th>
        <th>Title</th>
        <th>Description</th>
        <th></th>
      </tr>
    </thead>
    <tbody id="items-body"></tbody>
  </table>

  <div id="chat-overlay" class="chat-overlay" hidden>
    <div class="chat-panel">
      <div class="chat-header">
        <h3 id="chat-title"></h3>
        <button class="chat-close" id="chat-close">&times;</button>
      </div>
      <div class="chat-messages" id="chat-messages"></div>
      <div class="chat-input-area">
        <div class="chat-input-row">
          <textarea class="chat-content-input" id="chat-content" placeholder="Type a message..." rows="2"></textarea>
          <button class="chat-send-btn" id="chat-send">Send</button>
        </div>
      </div>
    </div>
  </div>

  <p id="message"></p>

  <script type="module">
    import Keycloak from "https://cdn.jsdelivr.net/npm/keycloak-js@26.2.0/lib/keycloak.js";

    const API = `${window.location.origin}/api`;
    const KEYCLOAK_URL = `http://${window.location.hostname}:8180`;

    const listSelect = document.getElementById("list-select");
    const itemsTable = document.getElementById("items-table");
    const itemsBody = document.getElementById("items-body");
    const message = document.getElementById("message");
    const userInfo = document.getElementById("user-info");
    const userName = document.getElementById("user-name");
    const authBtn = document.getElementById("auth-btn");
    const dateFilter = document.getElementById("date-filter");
    const venueFilter = document.getElementById("venue-filter");

    // All lists cache for filtering
    let allLists = [];

    // Chat panel elements
    const chatOverlay = document.getElementById("chat-overlay");
    const chatTitle = document.getElementById("chat-title");
    const chatMessages = document.getElementById("chat-messages");
    const chatContent = document.getElementById("chat-content");
    const chatSend = document.getElementById("chat-send");
    const chatClose = document.getElementById("chat-close");

    // Current item being discussed
    let currentChatItemId = null;

    // Keycloak instance
    const keycloak = new Keycloak({
      url: KEYCLOAK_URL,
      realm: 'claude-lists',
      clientId: 'claude-lists-web',
      checkLoginIframe: false
    });

    // Get auth headers for API requests
    function authHeaders() {
      const headers = { "Content-Type": "application/json" };
      if (keycloak.authenticated) {
        headers["Authorization"] = `Bearer ${keycloak.token}`;
      }
      return headers;
    }

    // User profile loaded from Keycloak
    let userProfile = null;

    // Get current user's display name
    function currentUserName() {
      if (userProfile) {
        return userProfile.username || userProfile.firstName || 'User';
      }
      if (keycloak.authenticated && keycloak.tokenParsed) {
        return keycloak.tokenParsed.preferred_username ||
               keycloak.tokenParsed.name ||
               keycloak.tokenParsed.sub?.substring(0, 8) ||
               'User';
      }
      return 'Anonymous';
    }

    // Update UI based on auth state
    function updateAuthUI() {
      if (keycloak.authenticated) {
        userName.textContent = currentUserName();
        authBtn.textContent = 'Logout';
        authBtn.className = 'auth-btn';
        authBtn.onclick = () => keycloak.logout();
      } else {
        userName.textContent = '';
        authBtn.textContent = 'Login';
        authBtn.className = 'auth-btn login';
        authBtn.onclick = () => keycloak.login();
      }
    }

    // Initialize the app after Keycloak is ready
    async function initApp() {
      if (keycloak.authenticated) {
        try {
          userProfile = await keycloak.loadUserProfile();
        } catch (e) {
          console.warn('Could not load user profile:', e);
        }
      }
      updateAuthUI();
      loadLists();
      connectWS();

      // Token refresh
      setInterval(() => {
        if (keycloak.authenticated) {
          keycloak.updateToken(30).catch(() => keycloak.login());
        }
      }, 30000);
    }

    // Fetch all lists and populate the dropdowns.
    async function loadLists() {
      const resp = await fetch(`${API}/lists?order=name`, { headers: authHeaders() });
      allLists = await resp.json();

      // Extract unique venues and dates
      const venues = new Set();
      const dates = new Set();
      allLists.forEach((list) => {
        if (list.metadata?.venue) venues.add(list.metadata.venue);
        if (list.metadata?.date) dates.add(list.metadata.date);
      });

      // Populate venue dropdown
      Array.from(venues).sort().forEach((venue) => {
        const opt = document.createElement("option");
        opt.value = venue;
        opt.textContent = venue;
        venueFilter.appendChild(opt);
      });

      // Set default date to today or nearest available date
      const today = new Date().toISOString().split('T')[0];
      const sortedDates = Array.from(dates).sort();
      const nearestDate = sortedDates.find(d => d >= today) || sortedDates[sortedDates.length - 1];
      if (nearestDate) {
        dateFilter.value = nearestDate;
      }

      filterLists();
    }

    // Filter lists based on date and venue selections
    function filterLists() {
      const selectedDate = dateFilter.value;
      const selectedVenue = venueFilter.value;

      // Clear current options
      listSelect.innerHTML = '<option value="">-- Select a list --</option>';

      // Filter and populate
      const filtered = allLists.filter((list) => {
        if (selectedDate && list.metadata?.date !== selectedDate) return false;
        if (selectedVenue && list.metadata?.venue !== selectedVenue) return false;
        return true;
      });

      filtered.forEach((list) => {
        const opt = document.createElement("option");
        opt.value = list.id;
        // Show type in the name if available
        const type = list.metadata?.type ? ` (${list.metadata.type})` : '';
        opt.textContent = list.name + type;
        listSelect.appendChild(opt);
      });

      // Clear items table when filters change
      itemsBody.innerHTML = "";
      itemsTable.hidden = true;
      message.textContent = filtered.length === 0 ? "No lists match the selected filters." : "";
    }

    // Fetch items for the selected list and render the table.
    let loadRequestId = 0;
    async function loadItems(listId) {
      const thisRequest = ++loadRequestId;
      itemsBody.innerHTML = "";

      if (!listId) {
        itemsTable.hidden = true;
        message.textContent = "";
        return;
      }

      // Fetch list (for headers) and items in parallel
      const [listResp, itemsResp] = await Promise.all([
        fetch(`${API}/lists?id=eq.${listId}`, { headers: authHeaders() }),
        fetch(`${API}/items?list_id=eq.${listId}&order=id`, { headers: authHeaders() })
      ]);
      if (thisRequest !== loadRequestId) return;

      const lists = await listResp.json();
      const items = await itemsResp.json();
      if (thisRequest !== loadRequestId) return;

      const list = lists[0] || {};
      const headers = list.metadata?.headers || [];

      itemsBody.innerHTML = "";

      if (items.length === 0 && headers.length === 0) {
        itemsTable.hidden = true;
        message.textContent = "No items in this list.";
        return;
      }

      message.textContent = "";
      itemsTable.hidden = false;

      // Fetch comment counts for all items in this list
      const itemIds = items.map(i => i.id);
      let commentCounts = {};
      if (itemIds.length > 0) {
        const commentsResp = await fetch(`${API}/comments?item_id=in.(${itemIds.join(",")})`, { headers: authHeaders() });
        if (thisRequest !== loadRequestId) return;
        const allComments = await commentsResp.json();

        // Count comments per item
        allComments.forEach(c => {
          commentCounts[c.item_id] = (commentCounts[c.item_id] || 0) + 1;
        });
      }

      // Group headers by position
      const headersByPosition = {};
      headers.forEach(h => {
        const pos = h.before_case || 'end';
        if (!headersByPosition[pos]) headersByPosition[pos] = [];
        headersByPosition[pos].push(h.text);
      });

      // Sort items by list_number from metadata
      const sortedItems = [...items].sort((a, b) => {
        const aNum = a.metadata?.list_number || 999;
        const bNum = b.metadata?.list_number || 999;
        return aNum - bNum;
      });

      // Helper to render combined headers in a single row
      function renderHeaders(texts) {
        const tr = document.createElement("tr");
        tr.className = "header-row";
        tr.innerHTML = `<td colspan="4" class="header-cell">${texts.map(t => escapeHtml(t)).join(' &middot; ')}</td>`;
        itemsBody.appendChild(tr);
      }

      // Track which headers we've rendered
      const renderedPositions = new Set();

      sortedItems.forEach((item) => {
        const listNum = item.metadata?.list_number;

        // Render any headers that should appear before this case
        if (listNum && headersByPosition[listNum] && !renderedPositions.has(listNum)) {
          renderHeaders(headersByPosition[listNum]);
          renderedPositions.add(listNum);
        }

        const tr = document.createElement("tr");
        if (item.done) tr.classList.add("done");

        // First column: undo button or empty
        if (item.done) {
          const undoBtn = document.createElement("button");
          undoBtn.className = "undo-btn";
          undoBtn.textContent = "\u21A9";
          undoBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            setDone(item.id, false);
          });
          const td = document.createElement("td");
          td.appendChild(undoBtn);
          tr.appendChild(td);
        } else {
          tr.innerHTML = `<td></td>`;
          tr.addEventListener("click", () => setDone(item.id, true));
        }

        // Title and description columns
        tr.insertAdjacentHTML("beforeend", `
          <td>${escapeHtml(item.title)}</td>
          <td>${escapeHtml(item.description || "")}</td>
        `);

        // Chat button column
        const chatTd = document.createElement("td");
        const chatBtn = document.createElement("button");
        const count = commentCounts[item.id] || 0;
        chatBtn.className = "chat-btn" + (count > 0 ? " has-comments" : "");
        chatBtn.innerHTML = "\uD83D\uDCAC" + (count > 0 ? `<span class="comment-count">${count}</span>` : "");
        chatBtn.title = count > 0 ? `${count} comment${count > 1 ? "s" : ""}` : "Start discussion";
        chatBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          openChat(item.id, item.title);
        });
        chatTd.appendChild(chatBtn);
        tr.appendChild(chatTd);

        itemsBody.appendChild(tr);
      });

      // Render any headers at the end (after_cases or position 'end')
      if (headersByPosition['end']) {
        renderHeaders(headersByPosition['end']);
      }
    }

    // Set the done status of an item via PATCH. UI updates via WebSocket.
    async function setDone(itemId, done) {
      await fetch(`${API}/items?id=eq.${itemId}`, {
        method: "PATCH",
        headers: authHeaders(),
        body: JSON.stringify({ done }),
      });
    }

    // Open chat panel for an item
    async function openChat(itemId, itemTitle) {
      currentChatItemId = itemId;
      chatTitle.textContent = itemTitle;
      chatOverlay.hidden = false;
      chatContent.focus();
      await loadComments(itemId);
    }

    // Close chat panel
    function closeChat() {
      chatOverlay.hidden = true;
      currentChatItemId = null;
      chatContent.value = "";
    }

    // Fetch and render comments for an item
    async function loadComments(itemId) {
      chatMessages.innerHTML = "";
      const resp = await fetch(`${API}/comments?item_id=eq.${itemId}&order=created_at`, { headers: authHeaders() });
      const comments = await resp.json();

      if (comments.length === 0) {
        chatMessages.innerHTML = '<div class="chat-empty">No comments yet. Start the discussion!</div>';
        return;
      }

      const myUserId = currentUserId();
      comments.forEach((comment) => {
        const div = document.createElement("div");
        const isOwn = comment.author_id && comment.author_id === myUserId;
        div.className = "chat-message" + (isOwn ? " own" : "");
        const time = new Date(comment.created_at).toLocaleString();

        const header = document.createElement("div");
        header.className = "chat-message-header";
        header.innerHTML = `
          <span class="chat-message-author">${escapeHtml(comment.author_name)}</span>
          <span class="chat-message-time">${escapeHtml(time)}</span>
        `;

        // Show delete button for own comments or if admin
        if (isOwn || isAdmin()) {
          const deleteBtn = document.createElement("button");
          deleteBtn.className = "chat-message-delete";
          deleteBtn.innerHTML = "&times;";
          deleteBtn.title = isOwn ? "Delete comment" : "Delete comment (admin)";
          deleteBtn.addEventListener("click", () => deleteComment(comment.id));
          header.appendChild(deleteBtn);
        }

        const content = document.createElement("div");
        content.className = "chat-message-content";
        content.textContent = comment.content;

        div.appendChild(header);
        div.appendChild(content);
        chatMessages.appendChild(div);
      });

      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // Delete a comment
    async function deleteComment(commentId) {
      await fetch(`${API}/comments?id=eq.${commentId}`, {
        method: "DELETE",
        headers: authHeaders(),
      });
    }

    // Get current user's ID (sub claim from JWT)
    function currentUserId() {
      if (keycloak.authenticated && keycloak.tokenParsed) {
        return keycloak.tokenParsed.sub;
      }
      return null;
    }

    // Check if current user is an admin
    function isAdmin() {
      if (keycloak.authenticated && keycloak.tokenParsed) {
        return keycloak.tokenParsed.role === 'web_admin';
      }
      return false;
    }

    // Send a new comment
    async function sendComment() {
      const content = chatContent.value.trim();

      if (!content || !currentChatItemId) return;

      chatSend.disabled = true;
      try {
        const commentData = {
          item_id: currentChatItemId,
          author_name: currentUserName(),
          content: content
        };
        // Include author_id if authenticated
        const userId = currentUserId();
        if (userId) {
          commentData.author_id = userId;
        }
        console.log('Sending comment:', commentData);
        const resp = await fetch(`${API}/comments`, {
          method: "POST",
          headers: authHeaders(),
          body: JSON.stringify(commentData),
        });
        if (!resp.ok) {
          const err = await resp.text();
          console.error('Comment failed:', resp.status, err);
          alert('Failed to send comment: ' + err);
          return;
        }
        chatContent.value = "";
      } catch (e) {
        console.error('Comment error:', e);
        alert('Error sending comment: ' + e.message);
      } finally {
        chatSend.disabled = false;
      }
    }

    // Prevent XSS when rendering user content.
    function escapeHtml(str) {
      const div = document.createElement("div");
      div.textContent = str;
      return div.innerHTML;
    }

    // Debounce loadItems so rapid WebSocket messages don't cause duplicates.
    let reloadTimer = null;
    function scheduleReload() {
      clearTimeout(reloadTimer);
      reloadTimer = setTimeout(() => loadItems(listSelect.value), 100);
    }

    // Debounce comment reload
    let commentReloadTimer = null;
    function scheduleCommentReload(itemId) {
      clearTimeout(commentReloadTimer);
      commentReloadTimer = setTimeout(() => {
        if (currentChatItemId === itemId) {
          loadComments(itemId);
        }
      }, 100);
    }

    // WebSocket connection for real-time updates with auto-reconnect.
    function connectWS() {
      const wsProto = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const ws = new WebSocket(`${wsProto}//${window.location.host}/ws`);
      ws.addEventListener("message", (event) => {
        const data = JSON.parse(event.data);
        // Handle item changes
        if (data.list_id !== undefined && data.item_id === undefined) {
          if (listSelect.value && String(data.list_id) === listSelect.value) {
            scheduleReload();
          }
        }
        // Handle comment changes
        if (data.item_id !== undefined) {
          scheduleCommentReload(data.item_id);
          // Also reload items to update comment counts
          if (listSelect.value && String(data.list_id) === listSelect.value) {
            scheduleReload();
          }
        }
      });
      ws.addEventListener("close", () => setTimeout(connectWS, 2000));
      ws.addEventListener("error", () => ws.close());
    }

    // Event listeners
    listSelect.addEventListener("change", () => loadItems(listSelect.value));
    dateFilter.addEventListener("change", filterLists);
    venueFilter.addEventListener("change", filterLists);
    chatClose.addEventListener("click", closeChat);
    chatOverlay.addEventListener("click", (e) => {
      if (e.target === chatOverlay) closeChat();
    });
    chatSend.addEventListener("click", sendComment);
    chatContent.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        sendComment();
      }
    });

    // Initialize Keycloak - login required
    console.log('Initializing Keycloak at', KEYCLOAK_URL);
    keycloak.init({
      onLoad: 'login-required'
    }).then(authenticated => {
      console.log('Keycloak init complete, authenticated:', authenticated);
      initApp();
    }).catch(err => {
      console.error('Keycloak init failed:', err);
      document.body.innerHTML = '<p style="padding: 2rem;">Authentication failed. Please refresh to try again.</p>';
    });
  </script>
</body>
</html>

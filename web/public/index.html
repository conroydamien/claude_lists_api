<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Claude Lists</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      max-width: 800px;
      margin: 40px auto;
      padding: 0 20px;
    }
    h1 {
      margin-bottom: 20px;
    }
    select {
      font-size: 1rem;
      padding: 6px 10px;
      margin-bottom: 20px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    th, td {
      text-align: left;
      padding: 8px 12px;
      border-bottom: 1px solid #ddd;
    }
    th {
      background: #f5f5f5;
    }
    .done td:not(:first-child) {
      text-decoration: line-through;
      color: #999;
    }
    tr:not(.done) {
      cursor: pointer;
    }
    tr:not(.done):hover {
      background: #f9f9f9;
    }
    .undo-btn, .chat-btn {
      background: none;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 2px 6px;
      cursor: pointer;
      font-size: 1.1rem;
      line-height: 1;
      color: #666;
    }
    .undo-btn:hover, .chat-btn:hover {
      background: #eee;
    }
    .chat-btn {
      margin-left: 4px;
    }
    .chat-btn.has-comments {
      background: #e3f2fd;
      border-color: #90caf9;
    }
    .comment-count {
      font-size: 0.75rem;
      margin-left: 2px;
    }
    #message {
      color: #666;
      font-style: italic;
    }
    /* Chat panel styles */
    .chat-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    .chat-overlay[hidden] {
      display: none;
    }
    .chat-panel {
      background: white;
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    }
    .chat-header {
      padding: 12px 16px;
      border-bottom: 1px solid #ddd;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .chat-header h3 {
      margin: 0;
      font-size: 1rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .chat-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: #666;
      line-height: 1;
    }
    .chat-close:hover {
      color: #333;
    }
    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      min-height: 200px;
      max-height: 400px;
    }
    .chat-message {
      margin-bottom: 12px;
      padding: 8px 12px;
      background: #f5f5f5;
      border-radius: 8px;
    }
    .chat-message.own {
      background: #e3f2fd;
      border-left: 3px solid #2196f3;
    }
    .chat-message-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
      font-size: 0.85rem;
      color: #666;
    }
    .chat-message-author {
      font-weight: 600;
      color: #333;
    }
    .chat-message-delete {
      background: none;
      border: none;
      color: #ccc;
      cursor: pointer;
      font-size: 0.9rem;
      padding: 0 4px;
      margin-left: 8px;
    }
    .chat-message-delete:hover {
      color: #e53935;
    }
    .chat-message-content {
      white-space: pre-wrap;
      word-break: break-word;
    }
    .chat-empty {
      color: #999;
      text-align: center;
      padding: 40px 20px;
    }
    .chat-input-area {
      padding: 12px 16px;
      border-top: 1px solid #ddd;
    }
    .chat-author-input {
      width: 100%;
      padding: 8px;
      margin-bottom: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 0.9rem;
    }
    .chat-input-row {
      display: flex;
      gap: 8px;
    }
    .chat-content-input {
      flex: 1;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 0.9rem;
      resize: none;
    }
    .chat-send-btn {
      padding: 8px 16px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .chat-send-btn:hover {
      background: #0056b3;
    }
    .chat-send-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    /* Auth UI styles */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    .header h1 {
      margin: 0;
    }
    .user-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .user-name {
      font-weight: 500;
      color: #333;
    }
    .auth-btn {
      padding: 8px 16px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: white;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .auth-btn:hover {
      background: #f5f5f5;
    }
    .auth-btn.login {
      background: #007bff;
      color: white;
      border-color: #007bff;
    }
    .auth-btn.login:hover {
      background: #0056b3;
    }
    .login-prompt {
      text-align: center;
      padding: 60px 20px;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Claude Lists</h1>
    <div class="user-info" id="user-info">
      <span class="user-name" id="user-name"></span>
      <button class="auth-btn" id="auth-btn">Loading...</button>
    </div>
  </div>

  <label for="list-select">Choose a list:</label>
  <select id="list-select">
    <option value="">-- Select a list --</option>
  </select>

  <table id="items-table" hidden>
    <thead>
      <tr>
        <th></th>
        <th>Title</th>
        <th>Description</th>
        <th></th>
      </tr>
    </thead>
    <tbody id="items-body"></tbody>
  </table>

  <div id="chat-overlay" class="chat-overlay" hidden>
    <div class="chat-panel">
      <div class="chat-header">
        <h3 id="chat-title"></h3>
        <button class="chat-close" id="chat-close">&times;</button>
      </div>
      <div class="chat-messages" id="chat-messages"></div>
      <div class="chat-input-area">
        <div class="chat-input-row">
          <textarea class="chat-content-input" id="chat-content" placeholder="Type a message..." rows="2"></textarea>
          <button class="chat-send-btn" id="chat-send">Send</button>
        </div>
      </div>
    </div>
  </div>

  <p id="message"></p>

  <script type="module">
    import Keycloak from "https://cdn.jsdelivr.net/npm/keycloak-js@26.2.0/lib/keycloak.js";

    const API = `http://${window.location.hostname}:3000`;
    const KEYCLOAK_URL = `http://${window.location.hostname}:8180`;

    const listSelect = document.getElementById("list-select");
    const itemsTable = document.getElementById("items-table");
    const itemsBody = document.getElementById("items-body");
    const message = document.getElementById("message");
    const userInfo = document.getElementById("user-info");
    const userName = document.getElementById("user-name");
    const authBtn = document.getElementById("auth-btn");

    // Chat panel elements
    const chatOverlay = document.getElementById("chat-overlay");
    const chatTitle = document.getElementById("chat-title");
    const chatMessages = document.getElementById("chat-messages");
    const chatContent = document.getElementById("chat-content");
    const chatSend = document.getElementById("chat-send");
    const chatClose = document.getElementById("chat-close");

    // Current item being discussed
    let currentChatItemId = null;

    // Keycloak instance
    const keycloak = new Keycloak({
      url: KEYCLOAK_URL,
      realm: 'claude-lists',
      clientId: 'claude-lists-web',
      checkLoginIframe: false
    });

    // Get auth headers for API requests
    function authHeaders() {
      const headers = { "Content-Type": "application/json" };
      if (keycloak.authenticated) {
        headers["Authorization"] = `Bearer ${keycloak.token}`;
      }
      return headers;
    }

    // User profile loaded from Keycloak
    let userProfile = null;

    // Get current user's display name
    function currentUserName() {
      if (userProfile) {
        return userProfile.username || userProfile.firstName || 'User';
      }
      if (keycloak.authenticated && keycloak.tokenParsed) {
        return keycloak.tokenParsed.preferred_username ||
               keycloak.tokenParsed.name ||
               keycloak.tokenParsed.sub?.substring(0, 8) ||
               'User';
      }
      return 'Anonymous';
    }

    // Update UI based on auth state
    function updateAuthUI() {
      if (keycloak.authenticated) {
        userName.textContent = currentUserName();
        authBtn.textContent = 'Logout';
        authBtn.className = 'auth-btn';
        authBtn.onclick = () => keycloak.logout();
      } else {
        userName.textContent = '';
        authBtn.textContent = 'Login';
        authBtn.className = 'auth-btn login';
        authBtn.onclick = () => keycloak.login();
      }
    }

    // Initialize the app after Keycloak is ready
    async function initApp() {
      if (keycloak.authenticated) {
        try {
          userProfile = await keycloak.loadUserProfile();
        } catch (e) {
          console.warn('Could not load user profile:', e);
        }
      }
      updateAuthUI();
      loadLists();
      connectWS();

      // Token refresh
      setInterval(() => {
        if (keycloak.authenticated) {
          keycloak.updateToken(30).catch(() => keycloak.login());
        }
      }, 30000);
    }

    // Fetch all lists and populate the dropdown.
    async function loadLists() {
      const resp = await fetch(`${API}/lists?order=name`, { headers: authHeaders() });
      const lists = await resp.json();
      lists.forEach((list) => {
        const opt = document.createElement("option");
        opt.value = list.id;
        opt.textContent = list.name;
        listSelect.appendChild(opt);
      });
    }

    // Fetch items for the selected list and render the table.
    let loadRequestId = 0;
    async function loadItems(listId) {
      const thisRequest = ++loadRequestId;
      itemsBody.innerHTML = "";

      if (!listId) {
        itemsTable.hidden = true;
        message.textContent = "";
        return;
      }

      const resp = await fetch(`${API}/items?list_id=eq.${listId}&order=id`, { headers: authHeaders() });
      if (thisRequest !== loadRequestId) return;
      const items = await resp.json();
      if (thisRequest !== loadRequestId) return;

      itemsBody.innerHTML = "";

      if (items.length === 0) {
        itemsTable.hidden = true;
        message.textContent = "No items in this list.";
        return;
      }

      message.textContent = "";
      itemsTable.hidden = false;

      // Fetch comment counts for all items in this list
      const itemIds = items.map(i => i.id);
      const commentsResp = await fetch(`${API}/comments?item_id=in.(${itemIds.join(",")})`, { headers: authHeaders() });
      if (thisRequest !== loadRequestId) return;
      const allComments = await commentsResp.json();

      // Count comments per item
      const commentCounts = {};
      allComments.forEach(c => {
        commentCounts[c.item_id] = (commentCounts[c.item_id] || 0) + 1;
      });

      items.forEach((item) => {
        const tr = document.createElement("tr");
        if (item.done) tr.classList.add("done");

        // First column: undo button or empty
        if (item.done) {
          const undoBtn = document.createElement("button");
          undoBtn.className = "undo-btn";
          undoBtn.textContent = "\u21A9";
          undoBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            setDone(item.id, false);
          });
          const td = document.createElement("td");
          td.appendChild(undoBtn);
          tr.appendChild(td);
        } else {
          tr.innerHTML = `<td></td>`;
          tr.addEventListener("click", () => setDone(item.id, true));
        }

        // Title and description columns
        tr.insertAdjacentHTML("beforeend", `
          <td>${escapeHtml(item.title)}</td>
          <td>${escapeHtml(item.description || "")}</td>
        `);

        // Chat button column
        const chatTd = document.createElement("td");
        const chatBtn = document.createElement("button");
        const count = commentCounts[item.id] || 0;
        chatBtn.className = "chat-btn" + (count > 0 ? " has-comments" : "");
        chatBtn.innerHTML = "\uD83D\uDCAC" + (count > 0 ? `<span class="comment-count">${count}</span>` : "");
        chatBtn.title = count > 0 ? `${count} comment${count > 1 ? "s" : ""}` : "Start discussion";
        chatBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          openChat(item.id, item.title);
        });
        chatTd.appendChild(chatBtn);
        tr.appendChild(chatTd);

        itemsBody.appendChild(tr);
      });
    }

    // Set the done status of an item via PATCH. UI updates via WebSocket.
    async function setDone(itemId, done) {
      await fetch(`${API}/items?id=eq.${itemId}`, {
        method: "PATCH",
        headers: authHeaders(),
        body: JSON.stringify({ done }),
      });
    }

    // Open chat panel for an item
    async function openChat(itemId, itemTitle) {
      currentChatItemId = itemId;
      chatTitle.textContent = itemTitle;
      chatOverlay.hidden = false;
      chatContent.focus();
      await loadComments(itemId);
    }

    // Close chat panel
    function closeChat() {
      chatOverlay.hidden = true;
      currentChatItemId = null;
      chatContent.value = "";
    }

    // Fetch and render comments for an item
    async function loadComments(itemId) {
      chatMessages.innerHTML = "";
      const resp = await fetch(`${API}/comments?item_id=eq.${itemId}&order=created_at`, { headers: authHeaders() });
      const comments = await resp.json();

      if (comments.length === 0) {
        chatMessages.innerHTML = '<div class="chat-empty">No comments yet. Start the discussion!</div>';
        return;
      }

      const myUserId = currentUserId();
      comments.forEach((comment) => {
        const div = document.createElement("div");
        const isOwn = comment.author_id && comment.author_id === myUserId;
        div.className = "chat-message" + (isOwn ? " own" : "");
        const time = new Date(comment.created_at).toLocaleString();

        const header = document.createElement("div");
        header.className = "chat-message-header";
        header.innerHTML = `
          <span class="chat-message-author">${escapeHtml(comment.author_name)}</span>
          <span class="chat-message-time">${escapeHtml(time)}</span>
        `;

        // Only show delete button for own comments
        if (isOwn) {
          const deleteBtn = document.createElement("button");
          deleteBtn.className = "chat-message-delete";
          deleteBtn.innerHTML = "&times;";
          deleteBtn.title = "Delete comment";
          deleteBtn.addEventListener("click", () => deleteComment(comment.id));
          header.appendChild(deleteBtn);
        }

        const content = document.createElement("div");
        content.className = "chat-message-content";
        content.textContent = comment.content;

        div.appendChild(header);
        div.appendChild(content);
        chatMessages.appendChild(div);
      });

      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // Delete a comment
    async function deleteComment(commentId) {
      await fetch(`${API}/comments?id=eq.${commentId}`, {
        method: "DELETE",
        headers: authHeaders(),
      });
    }

    // Get current user's ID (sub claim from JWT)
    function currentUserId() {
      if (keycloak.authenticated && keycloak.tokenParsed) {
        return keycloak.tokenParsed.sub;
      }
      return null;
    }

    // Send a new comment
    async function sendComment() {
      const content = chatContent.value.trim();

      if (!content || !currentChatItemId) return;

      chatSend.disabled = true;
      try {
        const commentData = {
          item_id: currentChatItemId,
          author_name: currentUserName(),
          content: content
        };
        // Include author_id if authenticated
        const userId = currentUserId();
        if (userId) {
          commentData.author_id = userId;
        }
        await fetch(`${API}/comments`, {
          method: "POST",
          headers: authHeaders(),
          body: JSON.stringify(commentData),
        });
        chatContent.value = "";
      } finally {
        chatSend.disabled = false;
      }
    }

    // Prevent XSS when rendering user content.
    function escapeHtml(str) {
      const div = document.createElement("div");
      div.textContent = str;
      return div.innerHTML;
    }

    // Debounce loadItems so rapid WebSocket messages don't cause duplicates.
    let reloadTimer = null;
    function scheduleReload() {
      clearTimeout(reloadTimer);
      reloadTimer = setTimeout(() => loadItems(listSelect.value), 100);
    }

    // Debounce comment reload
    let commentReloadTimer = null;
    function scheduleCommentReload(itemId) {
      clearTimeout(commentReloadTimer);
      commentReloadTimer = setTimeout(() => {
        if (currentChatItemId === itemId) {
          loadComments(itemId);
        }
      }, 100);
    }

    // WebSocket connection for real-time updates with auto-reconnect.
    function connectWS() {
      const ws = new WebSocket(`ws://${window.location.hostname}:9000`);
      ws.addEventListener("message", (event) => {
        const data = JSON.parse(event.data);
        // Handle item changes
        if (data.list_id !== undefined && data.item_id === undefined) {
          if (listSelect.value && String(data.list_id) === listSelect.value) {
            scheduleReload();
          }
        }
        // Handle comment changes
        if (data.item_id !== undefined) {
          scheduleCommentReload(data.item_id);
          // Also reload items to update comment counts
          if (listSelect.value && String(data.list_id) === listSelect.value) {
            scheduleReload();
          }
        }
      });
      ws.addEventListener("close", () => setTimeout(connectWS, 2000));
      ws.addEventListener("error", () => ws.close());
    }

    // Event listeners
    listSelect.addEventListener("change", () => loadItems(listSelect.value));
    chatClose.addEventListener("click", closeChat);
    chatOverlay.addEventListener("click", (e) => {
      if (e.target === chatOverlay) closeChat();
    });
    chatSend.addEventListener("click", sendComment);
    chatContent.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        sendComment();
      }
    });

    // Initialize Keycloak
    console.log('Initializing Keycloak at', KEYCLOAK_URL);
    keycloak.init({
      onLoad: 'check-sso'
    }).then(authenticated => {
      console.log('Keycloak init complete, authenticated:', authenticated);
      initApp();
    }).catch(err => {
      console.error('Keycloak init failed:', err);
      // Still initialize app without auth
      updateAuthUI();
      loadLists();
      connectWS();
    });
  </script>
</body>
</html>

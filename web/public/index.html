<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Claude Lists</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      max-width: 800px;
      margin: 40px auto;
      padding: 0 20px;
    }
    h1 {
      margin-bottom: 20px;
    }
    select, input[type="date"] {
      font-size: 1rem;
      padding: 6px 10px;
      margin-bottom: 20px;
    }
    .filters {
      display: flex;
      gap: 20px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }
    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .filter-group label {
      font-size: 0.85rem;
      color: #666;
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    th, td {
      text-align: left;
      padding: 8px 12px;
      border-bottom: 1px solid #ddd;
    }
    th {
      background: #f5f5f5;
    }
    .done td:not(:first-child) {
      text-decoration: line-through;
      color: #999;
    }
    tr:not(.done) {
      cursor: pointer;
    }
    tr:not(.done):hover {
      background: #f9f9f9;
    }
    .header-row {
      background: #f0f7ff;
      cursor: default;
    }
    .header-row:hover {
      background: #f0f7ff;
    }
    .header-cell {
      font-weight: 600;
      color: #1565c0;
      font-size: 0.95rem;
      padding: 12px;
      border-left: 3px solid #1976d2;
    }
    .undo-btn, .chat-btn {
      background: none;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 2px 6px;
      cursor: pointer;
      font-size: 1.1rem;
      line-height: 1;
      color: #666;
    }
    .undo-btn:hover, .chat-btn:hover {
      background: #eee;
    }
    .chat-btn {
      margin-left: 4px;
    }
    .chat-btn.has-comments {
      background: #e3f2fd;
      border-color: #90caf9;
    }
    .comment-count {
      font-size: 0.75rem;
      margin-left: 2px;
    }
    #message {
      color: #666;
      font-style: italic;
    }
    /* Chat panel styles */
    .chat-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    .chat-overlay[hidden] {
      display: none;
    }
    .chat-panel {
      background: white;
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    }
    .chat-header {
      padding: 12px 16px;
      border-bottom: 1px solid #ddd;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .chat-header h3 {
      margin: 0;
      font-size: 1rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .chat-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: #666;
      line-height: 1;
    }
    .chat-close:hover {
      color: #333;
    }
    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      min-height: 200px;
      max-height: 400px;
    }
    .chat-message {
      margin-bottom: 12px;
      padding: 8px 12px;
      background: #f5f5f5;
      border-radius: 8px;
    }
    .chat-message.own {
      background: #e3f2fd;
      border-left: 3px solid #2196f3;
    }
    .chat-message-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
      font-size: 0.85rem;
      color: #666;
    }
    .chat-message-author {
      font-weight: 600;
      color: #333;
    }
    .chat-message-delete {
      background: none;
      border: none;
      color: #ccc;
      cursor: pointer;
      font-size: 0.9rem;
      padding: 0 4px;
      margin-left: 8px;
    }
    .chat-message-delete:hover {
      color: #e53935;
    }
    .chat-message-content {
      white-space: pre-wrap;
      word-break: break-word;
    }
    .chat-empty {
      color: #999;
      text-align: center;
      padding: 40px 20px;
    }
    .chat-input-area {
      padding: 12px 16px;
      border-top: 1px solid #ddd;
    }
    .chat-author-input {
      width: 100%;
      padding: 8px;
      margin-bottom: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 0.9rem;
    }
    .chat-input-row {
      display: flex;
      gap: 8px;
    }
    .chat-content-input {
      flex: 1;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 0.9rem;
      resize: none;
    }
    .chat-send-btn {
      padding: 8px 16px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .chat-send-btn:hover {
      background: #0056b3;
    }
    .chat-send-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    /* Auth UI styles */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    .header h1 {
      margin: 0;
    }
    .user-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .user-name {
      font-weight: 500;
      color: #333;
    }
    .auth-btn {
      padding: 8px 16px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: white;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .auth-btn:hover {
      background: #f5f5f5;
    }
    .auth-btn.login {
      background: #007bff;
      color: white;
      border-color: #007bff;
    }
    .auth-btn.login:hover {
      background: #0056b3;
    }
    .login-prompt {
      text-align: center;
      padding: 60px 20px;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Claude Lists</h1>
    <div class="user-info" id="user-info">
      <span class="user-name" id="user-name"></span>
      <button class="auth-btn" id="auth-btn">Loading...</button>
    </div>
  </div>

  <div class="filters">
    <div class="filter-group">
      <label for="date-filter">Date:</label>
      <input type="date" id="date-filter">
    </div>
    <div class="filter-group">
      <label for="venue-filter">Venue:</label>
      <select id="venue-filter">
        <option value="">All venues</option>
      </select>
    </div>
  </div>

  <label for="list-select">Choose a list:</label>
  <select id="list-select">
    <option value="">-- Select a list --</option>
  </select>

  <table id="items-table" hidden>
    <thead>
      <tr>
        <th></th>
        <th>Title</th>
        <th>Description</th>
        <th></th>
      </tr>
    </thead>
    <tbody id="items-body"></tbody>
  </table>

  <div id="chat-overlay" class="chat-overlay" hidden>
    <div class="chat-panel">
      <div class="chat-header">
        <h3 id="chat-title"></h3>
        <button class="chat-close" id="chat-close">&times;</button>
      </div>
      <div class="chat-messages" id="chat-messages"></div>
      <div class="chat-input-area">
        <div class="chat-input-row">
          <textarea class="chat-content-input" id="chat-content" placeholder="Type a message..." rows="2"></textarea>
          <button class="chat-send-btn" id="chat-send">Send</button>
        </div>
      </div>
    </div>
  </div>

  <p id="message"></p>

  <script type="module">
    import Keycloak from "https://cdn.jsdelivr.net/npm/keycloak-js@26.2.0/lib/keycloak.js";

    const API = `${window.location.origin}/api`;
    const COURTS_IE = `${window.location.origin}/courts-ie`;
    const KEYCLOAK_URL = `http://${window.location.hostname}:8180`;

    const listSelect = document.getElementById("list-select");
    const itemsTable = document.getElementById("items-table");
    const itemsBody = document.getElementById("items-body");
    const message = document.getElementById("message");
    const userInfo = document.getElementById("user-info");
    const userName = document.getElementById("user-name");
    const authBtn = document.getElementById("auth-btn");
    const dateFilter = document.getElementById("date-filter");
    const venueFilter = document.getElementById("venue-filter");

    // All lists cache for filtering (from courts.ie)
    let allLists = [];
    // Current items from courts.ie
    let currentItems = [];
    // Current list metadata
    let currentList = null;
    // Maps local item IDs to database item IDs for comments
    const itemIdMap = new Map();

    // Chat panel elements
    const chatOverlay = document.getElementById("chat-overlay");
    const chatTitle = document.getElementById("chat-title");
    const chatMessages = document.getElementById("chat-messages");
    const chatContent = document.getElementById("chat-content");
    const chatSend = document.getElementById("chat-send");
    const chatClose = document.getElementById("chat-close");

    // Current item being discussed (local item)
    let currentChatItem = null;
    // Database item ID for the current chat
    let currentChatDbItemId = null;

    // Keycloak instance
    const keycloak = new Keycloak({
      url: KEYCLOAK_URL,
      realm: 'claude-lists',
      clientId: 'claude-lists-web',
      checkLoginIframe: false
    });

    // Get auth headers for API requests
    function authHeaders() {
      const headers = { "Content-Type": "application/json" };
      if (keycloak.authenticated) {
        headers["Authorization"] = `Bearer ${keycloak.token}`;
      }
      return headers;
    }

    // User profile loaded from Keycloak
    let userProfile = null;

    // Get current user's display name
    function currentUserName() {
      if (userProfile) {
        return userProfile.username || userProfile.firstName || 'User';
      }
      if (keycloak.authenticated && keycloak.tokenParsed) {
        return keycloak.tokenParsed.preferred_username ||
               keycloak.tokenParsed.name ||
               keycloak.tokenParsed.sub?.substring(0, 8) ||
               'User';
      }
      return 'Anonymous';
    }

    // Update UI based on auth state
    function updateAuthUI() {
      if (keycloak.authenticated) {
        userName.textContent = currentUserName();
        authBtn.textContent = 'Logout';
        authBtn.className = 'auth-btn';
        authBtn.onclick = () => keycloak.logout();
      } else {
        userName.textContent = '';
        authBtn.textContent = 'Login';
        authBtn.className = 'auth-btn login';
        authBtn.onclick = () => keycloak.login();
      }
    }

    // Initialize the app after Keycloak is ready
    async function initApp() {
      if (keycloak.authenticated) {
        try {
          userProfile = await keycloak.loadUserProfile();
        } catch (e) {
          console.warn('Could not load user profile:', e);
        }
      }
      updateAuthUI();

      // Set default date to today
      const today = new Date().toISOString().split('T')[0];
      dateFilter.value = today;

      loadListsForDate(today);
      connectWS();

      // Token refresh
      setInterval(() => {
        if (keycloak.authenticated) {
          keycloak.updateToken(30).catch(() => keycloak.login());
        }
      }, 30000);
    }

    // Multiple case number patterns for different courts (matching Android)
    const caseNumberPatterns = [
      // Circuit/District: 2024/1234, 123/2024
      /(\d{4}\/\d+|\d+\/\d{4})/,
      // Prefixed: CC123/2024, DS1234/2024, CL1234/2024
      /([A-Z]{1,4}\d+\/\d{4})/,
      // High Court style: 2024 No. 1234 P, 2024 No 1234
      /(\d{4}\s*No\.?\s*\d+\s*[A-Z]?)/,
      // Record numbers with prefix: Record No. 1234, Rec 1234
      /((?:Record|Rec)\.?\s*(?:No\.?)?\s*\d+)/i,
      // Spaced format: 2024 CC 123
      /(\d{4}\s+[A-Z]{1,4}\s+\d+)/,
      // General alphanumeric ref: AB12/34, 12AB34/2024
      /([A-Z0-9]{2,8}\/\d{4})/
    ];
    const listNumberPattern = /^(?:\d{1,2}:\d{2}[\s\t]+)?(\d+)\s+/;

    // Format date for courts.ie URL (dd-MM-yyyy)
    function formatDateForCourtsIe(dateStr) {
      const [year, month, day] = dateStr.split('-');
      return `${day}-${month}-${year}`;
    }

    // Parse date sort string (yyyymmdd) to ISO (yyyy-MM-dd)
    function parseDateSort(dateSort) {
      if (dateSort.length !== 8) return null;
      const year = dateSort.substring(0, 4);
      const month = dateSort.substring(4, 6);
      const day = dateSort.substring(6, 8);
      return `${year}-${month}-${day}`;
    }

    // Fetch lists from courts.ie for a specific date
    async function loadListsForDate(dateStr) {
      message.textContent = "Loading...";
      allLists = [];
      venueFilter.innerHTML = '<option value="">All venues</option>';
      listSelect.innerHTML = '<option value="">-- Select a list --</option>';
      itemsBody.innerHTML = "";
      itemsTable.hidden = true;

      try {
        const courtsDate = formatDateForCourtsIe(dateStr);
        const url = `${COURTS_IE}/legaldiary.nsf/circuit-court?OpenView&Jurisdiction=circuit-court&area=&type=&dateType=Range&dateFrom=${courtsDate}&dateTo=${courtsDate}&text=`;

        const resp = await fetch(url);
        const html = await resp.text();
        allLists = parseListingsPage(html, dateStr);

        // Extract unique venues
        const venues = new Set();
        allLists.forEach(list => {
          if (list.metadata?.venue) venues.add(list.metadata.venue);
        });

        // Populate venue dropdown
        Array.from(venues).sort().forEach(venue => {
          const opt = document.createElement("option");
          opt.value = venue;
          opt.textContent = venue;
          venueFilter.appendChild(opt);
        });

        filterLists();
      } catch (e) {
        console.error('Failed to load listings:', e);
        message.textContent = "Failed to load listings from courts.ie";
      }
    }

    // Parse courts.ie listing page HTML (matching Android logic)
    function parseListingsPage(html, dateStr) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const lists = [];

      // Find searchResults div and clickable rows
      const resultsDiv = doc.querySelector('#searchResults');
      if (!resultsDiv) {
        console.log('No #searchResults found');
        return lists;
      }

      const rows = resultsDiv.querySelectorAll('tr.clickable-row');
      let localId = 1;

      rows.forEach(row => {
        const dataUrl = row.getAttribute('data-url');
        if (!dataUrl) return;

        const cells = row.querySelectorAll('td');
        if (cells.length < 5) return;

        const dateText = cells[0].textContent.trim();
        const dateSort = cells[0].getAttribute('data-text') || '';
        const venue = cells[1].textContent.trim();
        const type = cells[2].textContent.trim();
        const subtitle = cells[3].textContent.trim();
        const updatedText = cells[4].textContent.trim();

        // Parse date from dateSort (yyyymmdd)
        const parsedDate = parseDateSort(dateSort) || dateStr;

        const name = subtitle || `${venue} - ${dateText}`;

        lists.push({
          id: localId++,
          name: name,
          description: type ? `${type} - ${venue}` : venue,
          metadata: {
            date: parsedDate,
            dateText: dateText,
            venue: venue,
            type: type || null,
            subtitle: subtitle || null,
            updated: updatedText || null,
            sourceUrl: `https://legaldiary.courts.ie${dataUrl}`,
            headers: []
          }
        });
      });

      console.log(`Parsed ${lists.length} diary entries`);
      return lists;
    }

    // Filter lists based on venue selection
    function filterLists() {
      const selectedVenue = venueFilter.value;

      // Clear current options
      listSelect.innerHTML = '<option value="">-- Select a list --</option>';

      // Filter and populate
      const filtered = allLists.filter(list => {
        if (selectedVenue && list.metadata?.venue !== selectedVenue) return false;
        return true;
      });

      filtered.forEach(list => {
        const opt = document.createElement("option");
        opt.value = list.id;
        const type = list.metadata?.type ? ` (${list.metadata.type})` : '';
        opt.textContent = list.name + type;
        listSelect.appendChild(opt);
      });

      // Clear items table when filters change
      itemsBody.innerHTML = "";
      itemsTable.hidden = true;
      message.textContent = filtered.length === 0 ? "No lists match the selected filters." : "";
    }

    // Fetch items from courts.ie detail page
    let loadRequestId = 0;
    async function loadItems(listId) {
      const thisRequest = ++loadRequestId;
      itemsBody.innerHTML = "";
      currentItems = [];
      currentList = null;

      if (!listId) {
        itemsTable.hidden = true;
        message.textContent = "";
        return;
      }

      const list = allLists.find(l => l.id === parseInt(listId));
      if (!list) {
        message.textContent = "List not found.";
        return;
      }

      currentList = list;
      message.textContent = "Loading cases...";

      try {
        // Fetch detail page from courts.ie via proxy
        const sourceUrl = list.metadata.sourceUrl;
        const proxyUrl = sourceUrl.replace('https://legaldiary.courts.ie', COURTS_IE);
        const resp = await fetch(proxyUrl);
        if (thisRequest !== loadRequestId) return;

        const html = await resp.text();
        const { items, headers } = parseDetailPage(html, list);
        currentItems = items;
        list.metadata.headers = headers;

        if (thisRequest !== loadRequestId) return;

        if (items.length === 0 && headers.length === 0) {
          itemsTable.hidden = true;
          message.textContent = "No items in this list.";
          return;
        }

        message.textContent = "";
        itemsTable.hidden = false;

        // Load comment counts for items that exist in database
        const commentCounts = await loadCommentCountsForItems(list, items);
        if (thisRequest !== loadRequestId) return;

        renderItems(items, headers, commentCounts);
      } catch (e) {
        console.error('Failed to load items:', e);
        message.textContent = "Failed to load cases from courts.ie";
      }
    }

    // Parse courts.ie detail page HTML (matching Android logic)
    function parseDetailPage(html, list) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');

      // Use .ld-content selector like Android
      const contentDiv = doc.querySelector('.ld-content');
      if (!contentDiv) {
        console.log('No .ld-content found');
        return { items: [], headers: [] };
      }

      let rawHtml = contentDiv.innerHTML;

      // Replace <br> tags with newlines (preserving tabs)
      rawHtml = rawHtml.replace(/<br\s*\/?>/gi, '\n');
      // Strip other HTML tags but keep text
      rawHtml = rawHtml.replace(/<[^>]+>/g, '');
      // Decode HTML entities
      rawHtml = rawHtml.replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&nbsp;/g, ' ')
        .replace(/&#39;/g, "'")
        .replace(/&quot;/g, '"');

      const lines = rawHtml.split('\n').map(l => l.trim()).filter(l => l.length > 0);
      console.log(`Extracted ${lines.length} lines from detail page`);

      return parseLines(lines, list);
    }

    // Parse a single line to extract case data (matching Android logic)
    function parseCaseItem(line) {
      // Check for list number at start (optionally preceded by time like "10:30")
      const listMatch = line.match(listNumberPattern);
      if (!listMatch) {
        return {
          listNumber: null,
          caseNumber: null,
          title: line,
          parties: null,
          isCase: false
        };
      }

      const listNumber = parseInt(listMatch[1]);
      const remainder = line.substring(listMatch[0].length).trim();

      // Try each case number pattern until one matches
      let caseMatch = null;
      for (const pattern of caseNumberPatterns) {
        caseMatch = remainder.match(pattern);
        if (caseMatch) break;
      }

      if (!caseMatch) {
        // No case number found, but still treat as a case if it has a list number
        return {
          listNumber: listNumber,
          caseNumber: null,
          title: line,
          parties: remainder || null,
          isCase: true  // Has list number, so it's a case entry
        };
      }

      const caseNumber = caseMatch[1];

      // Extract parties - text after case number
      const afterCaseNumIdx = remainder.indexOf(caseNumber) + caseNumber.length;
      let afterCaseNum = remainder.substring(afterCaseNumIdx).replace(/^[\t:\s]+/, '');

      // Split on colon or tab to get parties before solicitors
      const partiesMatch = afterCaseNum.split(/[:\t]/);
      const parties = partiesMatch[0]?.trim().replace(/[,:;\t\s]+$/, '') || null;

      return {
        listNumber: listNumber,
        caseNumber: caseNumber,
        title: line,
        parties: parties,
        isCase: true
      };
    }

    // Parse lines from detail page into items and headers (matching Android logic)
    function parseLines(lines, list) {
      const cases = [];
      const headers = [];
      const pendingHeaders = [];
      let localId = 1;

      for (const line of lines) {
        const parsed = parseCaseItem(line);
        if (parsed.isCase) {
          // Add pending headers
          headers.push(...pendingHeaders);
          pendingHeaders.length = 0;

          cases.push({
            id: localId++,
            listId: list.id,
            title: parsed.title,
            done: false,
            metadata: {
              isCase: true,
              listNumber: parsed.listNumber,
              caseNumber: parsed.caseNumber,
              parties: parsed.parties
            }
          });
        } else if (line.length > 3) {
          pendingHeaders.push(line);
        }
      }

      // Trailing headers
      headers.push(...pendingHeaders);

      // Convert headers to proper format with positions
      const formattedHeaders = headers.map((text, idx) => ({
        text: text,
        beforeCase: idx === 0 && cases.length > 0 ? cases[0].metadata.listNumber : null,
        afterCases: idx >= headers.length - pendingHeaders.length
      }));

      console.log(`Parsed ${cases.length} cases, ${formattedHeaders.length} headers`);
      return { items: cases, headers: formattedHeaders };
    }

    // Load comment counts for courts.ie items by checking database
    async function loadCommentCountsForItems(list, items) {
      const commentCounts = {};

      if (items.length === 0) return commentCounts;

      try {
        // Find if this list exists in database by source URL
        const sourceUrl = list.metadata.sourceUrl;
        const listResp = await fetch(
          `${API}/lists?metadata->>source_url=eq.${encodeURIComponent(sourceUrl)}`,
          { headers: authHeaders() }
        );
        const dbLists = await listResp.json();

        if (dbLists.length === 0) return commentCounts;

        const dbList = dbLists[0];

        // Get all case numbers from items
        const caseNumbers = items
          .filter(i => i.metadata?.caseNumber)
          .map(i => i.metadata.caseNumber);

        if (caseNumbers.length === 0) return commentCounts;

        // Fetch items from database for this list
        const itemsResp = await fetch(
          `${API}/items?list_id=eq.${dbList.id}`,
          { headers: authHeaders() }
        );
        const dbItems = await itemsResp.json();

        // Build map of case number to db item id
        const caseToDbId = new Map();
        dbItems.forEach(dbItem => {
          if (dbItem.metadata?.case_number) {
            caseToDbId.set(dbItem.metadata.case_number, dbItem.id);
          }
        });

        // Map local items to db items
        items.forEach(item => {
          if (item.metadata?.caseNumber && caseToDbId.has(item.metadata.caseNumber)) {
            itemIdMap.set(item.id, caseToDbId.get(item.metadata.caseNumber));
          }
        });

        // Fetch comment counts for db items
        const dbItemIds = Array.from(caseToDbId.values());
        if (dbItemIds.length > 0) {
          const commentsResp = await fetch(
            `${API}/comments?item_id=in.(${dbItemIds.join(',')})`,
            { headers: authHeaders() }
          );
          const comments = await commentsResp.json();

          // Count per db item id
          const dbCounts = {};
          comments.forEach(c => {
            dbCounts[c.item_id] = (dbCounts[c.item_id] || 0) + 1;
          });

          // Map back to local item ids
          items.forEach(item => {
            const dbId = itemIdMap.get(item.id);
            if (dbId && dbCounts[dbId]) {
              commentCounts[item.id] = dbCounts[dbId];
            }
          });
        }
      } catch (e) {
        console.error('Failed to load comment counts:', e);
      }

      return commentCounts;
    }

    // Render items in the table
    function renderItems(items, headers, commentCounts) {
      itemsBody.innerHTML = "";

      // Group headers by position
      const headersByPosition = {};
      headers.forEach(h => {
        const pos = h.beforeCase || 'end';
        if (!headersByPosition[pos]) headersByPosition[pos] = [];
        headersByPosition[pos].push(h.text);
      });

      // Sort items by list_number
      const sortedItems = [...items].sort((a, b) => {
        const aNum = a.metadata?.listNumber || 999;
        const bNum = b.metadata?.listNumber || 999;
        return aNum - bNum;
      });

      // Helper to render headers
      function renderHeaders(texts) {
        const tr = document.createElement("tr");
        tr.className = "header-row";
        tr.innerHTML = `<td colspan="4" class="header-cell">${texts.map(t => escapeHtml(t)).join(' &middot; ')}</td>`;
        itemsBody.appendChild(tr);
      }

      const renderedPositions = new Set();

      sortedItems.forEach(item => {
        const listNum = item.metadata?.listNumber;

        if (listNum && headersByPosition[listNum] && !renderedPositions.has(listNum)) {
          renderHeaders(headersByPosition[listNum]);
          renderedPositions.add(listNum);
        }

        const tr = document.createElement("tr");
        if (item.done) tr.classList.add("done");

        // First column: list number
        tr.innerHTML = `<td style="color: #666; width: 40px;">${listNum || ''}</td>`;

        // Title column
        tr.insertAdjacentHTML("beforeend", `
          <td>${escapeHtml(item.title)}</td>
          <td></td>
        `);

        // Chat button column
        const chatTd = document.createElement("td");
        const chatBtn = document.createElement("button");
        const count = commentCounts[item.id] || 0;
        chatBtn.className = "chat-btn" + (count > 0 ? " has-comments" : "");
        chatBtn.innerHTML = "\uD83D\uDCAC" + (count > 0 ? `<span class="comment-count">${count}</span>` : "");
        chatBtn.title = count > 0 ? `${count} comment${count > 1 ? "s" : ""}` : "Start discussion";
        chatBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          openChat(item);
        });
        chatTd.appendChild(chatBtn);
        tr.appendChild(chatTd);

        itemsBody.appendChild(tr);
      });

      if (headersByPosition['end']) {
        renderHeaders(headersByPosition['end']);
      }
    }

    // Ensure item exists in database (find or create)
    async function ensureItemInDatabase(item) {
      // Check if we already have a mapping
      if (itemIdMap.has(item.id)) {
        return itemIdMap.get(item.id);
      }

      if (!currentList) return null;

      try {
        // First, find or create the list in database
        const sourceUrl = currentList.metadata.sourceUrl;
        let listResp = await fetch(
          `${API}/lists?metadata->>source_url=eq.${encodeURIComponent(sourceUrl)}`,
          { headers: authHeaders() }
        );
        let dbLists = await listResp.json();

        let dbListId;
        if (dbLists.length === 0) {
          // Create the list
          const newList = {
            name: currentList.name,
            description: null,
            metadata: {
              date: currentList.metadata.date,
              date_text: currentList.metadata.dateText,
              venue: currentList.metadata.venue,
              type: currentList.metadata.type,
              source_url: sourceUrl,
              headers: currentList.metadata.headers
            }
          };
          const createResp = await fetch(`${API}/lists`, {
            method: 'POST',
            headers: { ...authHeaders(), 'Prefer': 'return=representation' },
            body: JSON.stringify(newList)
          });
          const created = await createResp.json();
          dbListId = created[0].id;
        } else {
          dbListId = dbLists[0].id;
        }

        // Now find or create the item
        const caseNumber = item.metadata?.caseNumber;
        if (caseNumber) {
          const itemResp = await fetch(
            `${API}/items?list_id=eq.${dbListId}&metadata->>case_number=eq.${encodeURIComponent(caseNumber)}`,
            { headers: authHeaders() }
          );
          const dbItems = await itemResp.json();

          if (dbItems.length > 0) {
            itemIdMap.set(item.id, dbItems[0].id);
            return dbItems[0].id;
          }
        }

        // Create the item
        const newItem = {
          list_id: dbListId,
          title: item.title,
          done: false,
          metadata: {
            is_case: true,
            list_number: item.metadata?.listNumber,
            case_number: item.metadata?.caseNumber,
            parties: item.metadata?.parties
          }
        };
        const createItemResp = await fetch(`${API}/items`, {
          method: 'POST',
          headers: { ...authHeaders(), 'Prefer': 'return=representation' },
          body: JSON.stringify(newItem)
        });
        const createdItem = await createItemResp.json();
        const dbItemId = createdItem[0].id;
        itemIdMap.set(item.id, dbItemId);
        return dbItemId;

      } catch (e) {
        console.error('Failed to ensure item in database:', e);
        return null;
      }
    }

    // Open chat panel for an item
    async function openChat(item) {
      currentChatItem = item;
      chatTitle.textContent = item.title;
      chatOverlay.hidden = false;
      chatContent.focus();
      chatMessages.innerHTML = '<div class="chat-empty">Loading...</div>';

      // Ensure item exists in database
      const dbItemId = await ensureItemInDatabase(item);
      if (!dbItemId) {
        chatMessages.innerHTML = '<div class="chat-empty">Failed to connect to database.</div>';
        return;
      }
      currentChatDbItemId = dbItemId;
      await loadComments(dbItemId);
    }

    // Close chat panel
    function closeChat() {
      chatOverlay.hidden = true;
      currentChatItem = null;
      currentChatDbItemId = null;
      chatContent.value = "";
    }

    // Fetch and render comments for an item
    async function loadComments(dbItemId) {
      chatMessages.innerHTML = "";
      const resp = await fetch(`${API}/comments?item_id=eq.${dbItemId}&order=created_at`, { headers: authHeaders() });
      const comments = await resp.json();

      if (comments.length === 0) {
        chatMessages.innerHTML = '<div class="chat-empty">No comments yet. Start the discussion!</div>';
        return;
      }

      const myUserId = currentUserId();
      comments.forEach((comment) => {
        const div = document.createElement("div");
        const isOwn = comment.author_id && comment.author_id === myUserId;
        div.className = "chat-message" + (isOwn ? " own" : "");
        const time = new Date(comment.created_at).toLocaleString();

        const header = document.createElement("div");
        header.className = "chat-message-header";
        header.innerHTML = `
          <span class="chat-message-author">${escapeHtml(comment.author_name)}</span>
          <span class="chat-message-time">${escapeHtml(time)}</span>
        `;

        // Show delete button for own comments or if admin
        if (isOwn || isAdmin()) {
          const deleteBtn = document.createElement("button");
          deleteBtn.className = "chat-message-delete";
          deleteBtn.innerHTML = "&times;";
          deleteBtn.title = isOwn ? "Delete comment" : "Delete comment (admin)";
          deleteBtn.addEventListener("click", () => deleteComment(comment.id));
          header.appendChild(deleteBtn);
        }

        const content = document.createElement("div");
        content.className = "chat-message-content";
        content.textContent = comment.content;

        div.appendChild(header);
        div.appendChild(content);
        chatMessages.appendChild(div);
      });

      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // Delete a comment
    async function deleteComment(commentId) {
      await fetch(`${API}/comments?id=eq.${commentId}`, {
        method: "DELETE",
        headers: authHeaders(),
      });
    }

    // Get current user's ID (sub claim from JWT)
    function currentUserId() {
      if (keycloak.authenticated && keycloak.tokenParsed) {
        return keycloak.tokenParsed.sub;
      }
      return null;
    }

    // Check if current user is an admin
    function isAdmin() {
      if (keycloak.authenticated && keycloak.tokenParsed) {
        return keycloak.tokenParsed.role === 'web_admin';
      }
      return false;
    }

    // Send a new comment
    async function sendComment() {
      const content = chatContent.value.trim();

      if (!content || !currentChatDbItemId) return;

      chatSend.disabled = true;
      try {
        const commentData = {
          item_id: currentChatDbItemId,
          author_name: currentUserName(),
          content: content
        };
        // Include author_id if authenticated
        const userId = currentUserId();
        if (userId) {
          commentData.author_id = userId;
        }
        console.log('Sending comment:', commentData);
        const resp = await fetch(`${API}/comments`, {
          method: "POST",
          headers: authHeaders(),
          body: JSON.stringify(commentData),
        });
        if (!resp.ok) {
          const err = await resp.text();
          console.error('Comment failed:', resp.status, err);
          alert('Failed to send comment: ' + err);
          return;
        }
        chatContent.value = "";
      } catch (e) {
        console.error('Comment error:', e);
        alert('Error sending comment: ' + e.message);
      } finally {
        chatSend.disabled = false;
      }
    }

    // Prevent XSS when rendering user content.
    function escapeHtml(str) {
      const div = document.createElement("div");
      div.textContent = str;
      return div.innerHTML;
    }

    // Debounce comment reload
    let commentReloadTimer = null;
    function scheduleCommentReload(dbItemId) {
      clearTimeout(commentReloadTimer);
      commentReloadTimer = setTimeout(() => {
        if (currentChatDbItemId === dbItemId) {
          loadComments(dbItemId);
        }
        // Refresh item list to update comment counts
        if (currentList && listSelect.value) {
          loadItems(listSelect.value);
        }
      }, 100);
    }

    // WebSocket connection for real-time comment updates
    function connectWS() {
      const wsProto = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const ws = new WebSocket(`${wsProto}//${window.location.host}/ws`);
      ws.addEventListener("message", (event) => {
        const data = JSON.parse(event.data);
        // Handle comment changes - check if it matches any mapped item
        if (data.item_id !== undefined) {
          scheduleCommentReload(data.item_id);
        }
      });
      ws.addEventListener("close", () => setTimeout(connectWS, 2000));
      ws.addEventListener("error", () => ws.close());
    }

    // Event listeners
    listSelect.addEventListener("change", () => loadItems(listSelect.value));
    dateFilter.addEventListener("change", () => loadListsForDate(dateFilter.value));
    venueFilter.addEventListener("change", filterLists);
    chatClose.addEventListener("click", closeChat);
    chatOverlay.addEventListener("click", (e) => {
      if (e.target === chatOverlay) closeChat();
    });
    chatSend.addEventListener("click", sendComment);
    chatContent.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        sendComment();
      }
    });

    // Initialize Keycloak - login required
    console.log('Initializing Keycloak at', KEYCLOAK_URL);
    keycloak.init({
      onLoad: 'login-required'
    }).then(authenticated => {
      console.log('Keycloak init complete, authenticated:', authenticated);
      initApp();
    }).catch(err => {
      console.error('Keycloak init failed:', err);
      document.body.innerHTML = '<p style="padding: 2rem;">Authentication failed. Please refresh to try again.</p>';
    });
  </script>
</body>
</html>
